package org.geoserver.wcs.responses;

import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertTrue;

import java.io.File;
import java.io.IOException;

import javax.xml.namespace.QName;

import org.apache.commons.io.FileUtils;
import org.geoserver.catalog.CoverageInfo;
import org.geoserver.catalog.DimensionPresentation;
import org.geoserver.catalog.ResourceInfo;
import org.geoserver.data.test.MockData;
import org.geoserver.data.test.SystemTestData;
import org.geoserver.wcs2_0.GetCoverage;
import org.geoserver.wcs2_0.WCSTestSupport;
import org.geotools.coverage.grid.GridCoverage2D;
import org.geotools.coverage.grid.io.GridCoverage2DReader;
import org.geotools.data.DataSourceException;
import org.geotools.gce.geotiff.GeoTiffReader;
import org.geotools.gce.imagemosaic.ImageMosaicFormat;
import org.geotools.geometry.GeneralEnvelope;
import org.geotools.referencing.CRS;
import org.junit.Before;
import org.junit.Test;
import org.opengis.coverage.grid.GridEnvelope;

import com.mockrunner.mock.web.MockHttpServletResponse;
/**
 * Testing WCS 2.0 Core {@link GetCoverage}
 * 
 * @author Simone Giannecchini, GeoSolutions SAS
 * @author Emanuele Tajariol, GeoSolutions SAS
 *
 */
public class GetCoverageTest extends WCSTestSupport {
    
    protected static QName TIMERANGES = new QName(MockData.SF_URI, "time_domainsRanges", MockData.SF_PREFIX);

    
    @Before
    public void clearDimensions() {
        clearDimensions(getLayerId(TIMERANGES));
    }
    
    @Override
    protected void onSetUp(SystemTestData testData) throws Exception {
        super.onSetUp(testData);
        testData.addRasterLayer(TIMERANGES, "timeranges.zip", null, null, SystemTestData.class, getCatalog());
        sortByElevation(TIMERANGES);
    }

    // force sorting on elevation to get predictable results
    private void sortByElevation(QName layer) {
        CoverageInfo coverage = getCatalog().getCoverageByName(getLayerId(layer));
        String sortByKey = ImageMosaicFormat.SORT_BY.getName().toString();
        coverage.getParameters().put(sortByKey, "elevation");
        getCatalog().save(coverage);
    }

    @Test
    public void testCoverageTimeElevationTrimmingLowValuesGranule() throws Exception {
        setupRasterDimension(getLayerId(TIMERANGES), ResourceInfo.TIME, DimensionPresentation.LIST, null);
        setupRasterDimension(getLayerId(TIMERANGES), ResourceInfo.ELEVATION, DimensionPresentation.LIST, null);
        setupRasterDimension(getLayerId(TIMERANGES), ResourceInfo.CUSTOM_DIMENSION_PREFIX + "WAVELENGTH", DimensionPresentation.LIST, null);
        final File xml = new File("./src/test/resources/trimming/requestGetCoverageTimeElevationTrimmingXML.xml");
        String request= FileUtils.readFileToString(xml);
        request = request.replace("${coverageId}", "sf__time_domainsRanges");
        request = request.replace("${startTime}", "2008-10-31T00:00:00.000Z");
        request = request.replace("${endTime}", "2008-11-03T00:00:00.000Z");
        request = request.replace("${startElevation}", "15");
        request = request.replace("${endElevation}", "90");
        request = request.replace("${startWavelength}", "13");
        request = request.replace("${endWavelength}", "22");
        // timeranges is really just an expanded watertemp 
        checkWaterTempValue(request, 18.478999927756377);
    }

    private void checkWaterTempValue(String request, double expectedValue) throws Exception, IOException,
            DataSourceException {
        MockHttpServletResponse response = postAsServletResponse("wcs", request);
        
        assertEquals("image/tiff", response.getContentType());
        byte[] tiffContents = getBinary(response);
        File file = File.createTempFile("bm_gtiff", "bm_gtiff.tiff", new File("./target"));
        FileUtils.writeByteArrayToFile(file, tiffContents);

        GeoTiffReader readerTarget = new GeoTiffReader(file);
        GridCoverage2D targetCoverage = null;
        try {
            targetCoverage = readerTarget.read(null);

            // checks spatial consistency
            GridCoverage2DReader sourceReader = (GridCoverage2DReader) getCatalog().getCoverageByName(getLayerId(TIMERANGES)).getGridCoverageReader(null, null);
            GeneralEnvelope expectedEnvelope  = sourceReader.getOriginalEnvelope();
            assertEnvelopeEquals(expectedEnvelope, 1.0,(GeneralEnvelope) targetCoverage.getEnvelope(), 1.0);
            assertTrue(CRS.equalsIgnoreMetadata(targetCoverage.getCoordinateReferenceSystem(), expectedEnvelope.getCoordinateReferenceSystem()));
            
            // check raster space consistency
            final GridEnvelope gridRange = targetCoverage.getGridGeometry().getGridRange();
            GridEnvelope expectedGridRange = sourceReader.getOriginalGridRange();
            assertEquals(gridRange.getSpan(0), expectedGridRange.getSpan(0));
            assertEquals(gridRange.getSpan(1), expectedGridRange.getSpan(1));
            
            // check the reference pixel 
            double[] pixel = new double[1];
            targetCoverage.getRenderedImage().getData().getPixel(1, 24, pixel);
            assertEquals(expectedValue, pixel[0], 1e-6);
        } finally {
            readerTarget.dispose();
            scheduleForCleaning(targetCoverage);
        }
    }
}

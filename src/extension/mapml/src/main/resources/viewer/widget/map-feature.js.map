{"version":3,"file":"map-feature.js","sources":["../src/map-feature.js"],"sourcesContent":["export class MapFeature extends HTMLElement {\n    static get observedAttributes() {\n      return ['zoom'];\n    }\n\n    get zoom() {\n      return +(this.hasAttribute(\"zoom\") ? this.getAttribute(\"zoom\") : 0);\n    }\n\n    set zoom(val) {\n      var parsedVal = String.toString(parseInt(val,10));\n      if (!isNaN(parsedVal) && (parsedVal >= 0 && parsedVal <= 25)) {\n        this.setAttribute('zoom', parsedVal);\n      }\n    }\n\n    get extent() {\n      if (this.isConnected) {\n        return this._getFeatureExtent();\n      }\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      switch (name) {\n        case 'zoom': {\n          if (oldValue !== newValue && this._layerParent) {\n            this._remove();\n            this._redraw();\n          }\n          break;\n        }\n      }\n    }\n\n    constructor() {\n      // Always call super first in constructor\n      super();\n    }\n\n    connectedCallback() {\n      if (this.parentNode.nodeType !== document.DOCUMENT_FRAGMENT_NODE && \n          this.parentNode.tagName.toLowerCase() !== 'layer-') {\n        return;\n      }\n\n      this._layerParent = this.parentNode._layer ? this.parentNode._layer : this.parentNode.host._layer;\n      this._map = this._layerParent._map;\n      if(this._layerParent._layerEl.hasAttribute(\"data-moving\")) return;\n      \n      this._observer = new MutationObserver((mutationList) => {\n        // map-properties, map-geometry, map-featurecaption, map-a\n        for (let i = 0; i < mutationList.length; ++i) {\n          this._remove();\n          this._redraw();\n        }\n      });\n      // Start observing the target node for configured mutations\n      this._observer.observe(this, { \n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeOldValue: true,\n        characterData: true\n      });\n\n      if (!this._featureLayer) {\n        this._redraw();\n      } else {\n        // link to the leaflet featuresgroup\n        // done in FeatureLayer.js -> MapMLLayer.js\n        // can be accessed by this._featureLayer\n        this._groupEl = this._featureLayer.options.group;\n      }\n\n    }\n      \n    disconnectedCallback() {\n      if(this._layerParent._layerEl.hasAttribute(\"data-moving\")) return;\n      this._remove();\n      this._observer.disconnect();\n    }\n\n    _remove() {\n      // if the <layer- > el is disconnected\n      // the <g> el has already got removed at this point\n      if (this._groupEl.isConnected) {\n        this._groupEl.parentNode.removeChild(this._groupEl);\n      }\n      // if the <layer- > el has already been disconnected,\n      // then _map.removeLayer(layerEl._layer) has already been invoked (inside layerEl.disconnectedCallback())\n      // this._featureLayer has already got removed at this point\n      if (this._featureLayer._map) {\n        this._featureLayer._map.removeLayer(this._featureLayer);\n      }\n      delete this._featureLayer;\n      delete this._groupEl;\n    }\n\n    // re-add / update features\n    _redraw() {\n      let nativeZoom = this.closest(\"map-meta[name=zoom]\")?.getAttribute('content')?.split(',').find(zoom => zoom.includes('value')) || 0,\n          nativeCS = this.closest(\".map-meta[name=cs]\")?.getAttribute('content') || 'pcrs',\n          mapmlvectors = this._layerParent._mapmlvectors;\n      if (mapmlvectors) {\n        // the <layer- > is not removed\n        this._featureLayer = this._layerParent._mapmlvectors.addData(this, nativeCS, +nativeZoom);\n        this._featureLayer.addTo(this._map);\n        let features = this._featureLayer._layers;\n        for (const key in features) {\n          features[key].addTo(this._map);\n        }\n        this._groupEl = this._featureLayer.options.group;\n      } else {\n        this._layerParent.once(\"attachmapml\", function () {\n          this._featureLayer = this._layerParent._mapmlvectors.addData(this, nativeCS, +nativeZoom);\n          this._featureLayer.addTo(this._map);\n          let features = this._featureLayer._layers;\n          for (const key in features) {\n            features[key].addTo(this._map);\n          }\n          this._groupEl = this._featureLayer.options.group;\n        }, this);\n      }\n    }\n\n    // Util functions:\n    // internal support for returning a GeoJSON representation of <map-feature> geometry\n    // propertyFunction (optional): the function used to format the innerHTML of <map-properties>\n    geometryToGeoJSON(propertyFunction) {\n      let json = {}, count = 0;\n      let shapes = this._featureLayer._layers;\n      for (let id in shapes) {\n        let j = json[count] = {};\n        let el = this.querySelector('map-properties');\n        // transform to gcrs\n        let source = null, dest = null, transform = false;\n        if (this._map.options.crs.code !== \"EPSG:3857\" || this._map.options.crs.code  !== \"EPSG:4326\") {\n          source = new proj4.Proj(this._map.options.crs.code);\n          dest = new proj4.Proj('EPSG:4326');\n          transform = true;\n        }\n        j.geometry = M._geometry2geojson(shapes[id]._markup, source, dest, transform);\n\n        if (propertyFunction) {\n          j.properties = propertyFunction(el);\n        } else if (el.querySelector('table') !== null) { \n          // setting properties when table presented\n          j.properties = M._table2properties(el.querySelector('table'));\n        } else {\n          // when no table present, strip any possible html tags to only get text\n          j.properties = {prop0: (el.innerHTML).replace( /(<([^>]+)>)/ig, '').replace(/\\s/g, '')};\n        }\n        count++;\n      }\n      return json;\n    }\n\n    // method to calculate and return the extent of the feature as a JavaScript object\n    _getFeatureExtent() {\n      let map = this._map,\n          geometry = this.querySelector('map-geometry'),\n          nativeCS = this.closest(\".map-meta[name=cs]\")?.getAttribute('content') || 'pcrs',\n          cs = geometry.getAttribute('cs') || nativeCS,\n          shapes = geometry.querySelectorAll(\"map-point, map-linestring, map-polygon, map-multipoint, map-multilinestring\"),\n          bboxExtent = [Infinity, Infinity, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\n      for (let shape of shapes) {\n        let coord = shape.querySelectorAll('map-coordinates');\n        for (let i = 0; i < coord.length; ++i) {\n          _updateExtent(shape, coord[i]);\n        }\n      }\n      let topLeft = L.point(bboxExtent[0], bboxExtent[1]);\n      let bottomRight = L.point(bboxExtent[2], bboxExtent[3]);\n      let pcrsBound = M.boundsToPCRSBounds(L.bounds(topLeft, bottomRight), map.getZoom(), map.options.projection, cs);\n      return M._convertAndFormatPCRS(pcrsBound, map);\n\n      function _updateExtent(shape, coord) {\n        let data = coord.innerHTML.split(' ');\n        switch (shape.tagName) {\n          case \"MAP-POINT\":\n            bboxExtent = M._updateExtent(bboxExtent, +data[0], +data[1]);\n            break;\n          case \"MAP-LINESTRING\":\n          case \"MAP-POLYGON\":\n          case \"MAP-MULTIPOINT\":\n          case \"MAP-MULTILINESTRING\":\n            for (let i = 0; i < data.length; i += 2) {\n              bboxExtent = M._updateExtent(bboxExtent, +data[i], +data[i + 1]);\n            }\n            break;\n          default:\n            break;\n        }\n      }\n    }\n\n    // a .click() method that highlights the feature and show popup on map as if doing a click\n    click(event) {\n      let g = this._groupEl,\n          rect = g.getBoundingClientRect();\n      if (!event) {\n        event = new MouseEvent (\"mousedown\", {\n          clientX: rect.x + rect.width / 2,\n          clientY: rect.y + rect.height / 2,\n          button: 0\n        });\n      }\n      if (typeof this.onclick === 'function') {\n        this.onclick(this, event);\n        return;\n      } else {\n        let properties = this.querySelector('map-properties');\n        this.focus(event);\n        if (g.getAttribute('role') === 'link') {\n          for (let path of g.children) {\n            path.mousedown.call(this._featureLayer, event);\n            path.mouseup.call(this._featureLayer, event);\n          }\n          document.dispatchEvent(new MouseEvent('click', {\n            bubbles: false\n          }));\n        }\n        // AFTER the mousedown and mouseup events:\n        // case 1: the layer el is not re-attached to the map, the <map-feature> el is still CONNECTED\n        // case 2: the layer el is re-attached to the map; the disconnectedCallback() is invoked;\n        //         the <map-feature> el (THIS) is now DISCONNECTED, this._featureLayer is removed and a new featureLayer is created\n        if (properties && this.isConnected) {\n          this._featureLayer.isPopupOpen() ? this._featureLayer.closePopup() : this._featureLayer.openPopup();\n        }\n      }\n    }\n    \n    focus(event) {\n      let g = this._groupEl,\n          featureLayer = this._featureLayer,\n          rect = g.getBoundingClientRect();\n      if (!event) {\n        event = new MouseEvent (\"mousedown\", {\n          clientX: rect.x + rect.width / 2,\n          clientY: rect.y + rect.height / 2,\n          button: 0,\n        });\n      }\n      if (typeof this.onfocus === 'function') {\n        this.onfocus(this, event);\n        return;\n      } else if (g.getAttribute('role') === 'button' || \n                 g.getAttribute('role') === 'link' ||\n                 g.getAttribute('tabindex') === \"0\") {\n        g.classList.toggle('focus');\n        document.addEventListener('click', _removeFocusState, true);\n      }\n\n      function _removeFocusState (e) {\n        e.preventDefault();\n        e.stopPropagation();\n        if (g.classList.contains('focus')) {\n          g.classList.remove('focus');\n        }\n        if (featureLayer?.isPopupOpen()) {\n          featureLayer.closePopup();\n        }\n        document.removeEventListener('click', _removeFocusState);\n      }\n    }\n  }\n"],"names":["MapFeature","HTMLElement","observedAttributes","zoom","this","hasAttribute","getAttribute","val","parsedVal","String","toString","parseInt","isNaN","setAttribute","extent","isConnected","_getFeatureExtent","attributeChangedCallback","name","oldValue","newValue","_layerParent","_remove","_redraw","constructor","super","connectedCallback","parentNode","nodeType","document","DOCUMENT_FRAGMENT_NODE","tagName","toLowerCase","_layer","host","_map","_layerEl","_observer","MutationObserver","let","i","mutationList","length","observe","childList","subtree","attributes","attributeOldValue","characterData","_featureLayer","_groupEl","options","group","disconnectedCallback","disconnect","removeChild","removeLayer","nativeZoom","closest","split","find","includes","nativeCS","mapmlvectors","_mapmlvectors","addData","addTo","features","_layers","key","once","geometryToGeoJSON","propertyFunction","json","count","id","shapes","j","el","querySelector","source","dest","transform","crs","code","proj4","Proj","geometry","M","_geometry2geojson","_markup","properties","_table2properties","prop0","replace","map","cs","querySelectorAll","bboxExtent","Infinity","Number","NEGATIVE_INFINITY","shape","coord","data","innerHTML","_updateExtent","topLeft","L","point","bottomRight","pcrsBound","boundsToPCRSBounds","bounds","getZoom","projection","_convertAndFormatPCRS","click","event","g","rect","getBoundingClientRect","MouseEvent","clientX","x","width","clientY","y","height","button","onclick","focus","path","children","mousedown","call","mouseup","dispatchEvent","bubbles","isPopupOpen","closePopup","openPopup","featureLayer","onfocus","classList","toggle","addEventListener","_removeFocusState","e","preventDefault","stopPropagation","contains","remove","removeEventListener"],"mappings":"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"}